/* * Name: Minji Ahn * NetID: mja104 * Date: 2/17/19 */#ifndef _MYQUEUE_H_#define _MYQUEUE_H_using namespace std;template <class T>class myQueue {public:    myQueue(int maxSz);    ~myQueue();    void enqueue(T item);    T dequeue();    int currentSize();    bool isEmpty();    bool isFull();private:    T *contents; /*Dynamic initiate (C++ keyword new) the holder array*/    int front,rear;  /*Index in the array of the front and rear element*/    int arrayLength;  /*The length of the contents holder array*/    /* Keep in mind that the Queue will only hold up to (arrayLength - 1) elements*/};template <class T>myQueue<T>::myQueue(int maxSz) {    // TODO    front = -1;    rear = -1;    arrayLength = maxSz;    contents = new T[maxSz];}template <class T>myQueue<T>::~myQueue() {    // TODO    delete [] contents;}template <class T>void myQueue<T>::enqueue(T item) {    // TODO    rear++;    contents[rear] = item;}template <class T>T myQueue<T>::dequeue() {    // TODO    front++;    T temp = contents[front];    return temp;}template <class T>int myQueue<T>::currentSize() {    // TODO    int size = (rear - front + arrayLength)% arrayLength;    if(size == 0)        return rear - front;    else        return size;}template <class T>bool myQueue<T>::isEmpty() {    // TODO    return front == rear;}template <class T>bool myQueue<T>::isFull() {    // TODO    return currentSize() == arrayLength;}#endif